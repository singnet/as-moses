/** InterpreterUTest.cxxtest ---
 *
 * Copyright (C) 2018 OpenCog Foundation
 *
 * Author: Kasim Ebrahim
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License v3 as
 * published by the Free Software Foundation and including the exceptions
 * at http://opencog.org/wiki/Licenses
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program; if not, write to:
 * Free Software Foundation, Inc.,
 * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
 */


#include <opencog/atoms/base/Handle.h>
#include <opencog/atoms/base/Link.h>
#include <opencog/atoms/base/Node.h>
#include <moses/atomese/interpreter/Interpreter.h>
#include <moses/atomese/interpreter/logical_interpreter.h>
#include <opencog/atoms/core/NumberNode.h>
#include <opencog/atoms/proto/LinkValue.h>


using namespace std;
using namespace opencog;


class InterpreterUTest : public CxxTest::TestSuite{
private:
	Handle dataset;
	Handle dataset_boolean;
	Handle f1;
	Handle f2;
	Handle f3;
	Handle _size;
	Handle f1_tv;
	Handle f2_tv;
	Handle f3_tv;
	ProtoAtomPtr t_link;
	ProtoAtomPtr f_link;

public:
	InterpreterUTest(){
		// initialization of problem_data [schema]
		dataset = createNode(SCHEMA_NODE, "problem-data");

		f1 = createNode(SCHEMA_NODE, "*-AS-MOSES:featureOneKey-*");
		f2 = createNode(SCHEMA_NODE, "*-AS-MOSES:featureTwoKey-*");
		f3 = createNode(SCHEMA_NODE, "*-AS-MOSES:featureThreeKey-*");
		_size = createNode(NODE, "*-AS-MOSES:dataSize-*");

		std::vector<double> _f1_values = {1.0, 0.0, 0.0};
		std::vector<double> _f2_values = {0.0, 1.0, 0.0};
		std::vector<double> _f3_values = {0.0, 0.0, 0.0};
		std::vector<double> _size_value = {3};

		ProtoAtomPtr _size_proto_atom(new FloatValue(_size_value));
		dataset->setValue(_size, _size_proto_atom);

		ProtoAtomPtr f1_proto_atom(new FloatValue(_f1_values));
		dataset->setValue(f1, f1_proto_atom);

		ProtoAtomPtr f2_proto_atom(new FloatValue(_f2_values));
		dataset->setValue(f2, f2_proto_atom);

		ProtoAtomPtr f3_proto_atom(new FloatValue(_f3_values));
		dataset->setValue(f3, f3_proto_atom);

		// initialization of problem_data [predicate]
		dataset_boolean = createNode(PREDICATE_NODE, "problem-data");

		dataset_boolean->setValue(_size, _size_proto_atom);

		f1_tv = createNode(PREDICATE_NODE, "*-AS-MOSES:featureOneKey-*");
		f2_tv = createNode(PREDICATE_NODE, "*-AS-MOSES:featureTwoKey-*");
		f3_tv = createNode(PREDICATE_NODE, "*-AS-MOSES:featureThreeKey-*");

		t_link = ProtoAtomPtr(createLink(TRUE_LINK));
		f_link = ProtoAtomPtr(createLink(FALSE_LINK));

		std::vector<ProtoAtomPtr> _f1_tv = {t_link, t_link, f_link};
		std::vector<ProtoAtomPtr> _f2_tv = {f_link, t_link, f_link};
		std::vector<ProtoAtomPtr> _f3_tv = {f_link, f_link, t_link};

		ProtoAtomPtr f1_tv_proto_atom(new LinkValue(_f1_tv));
		dataset_boolean->setValue(f1_tv, f1_tv_proto_atom);

		ProtoAtomPtr f2_tv_proto_atom(new LinkValue(_f2_tv));
		dataset_boolean->setValue(f2_tv, f2_tv_proto_atom);

		ProtoAtomPtr f3_tv_proto_atom(new LinkValue(_f3_tv));
		dataset_boolean->setValue(f3_tv, f3_tv_proto_atom);
	}

	void test_interpret(void)
	{
		// Atomese program to be evaluated over the problem_data
		HandleSeq seq = {f1, f2, f3};
		Handle program = createLink(seq, PLUS_LINK);

		// expected out put vector
		std::vector<double> exp_value = {1.0, 1.0, 0.0};

		// interpret
		atomese::Interpreter interpreter(dataset);
		ProtoAtomPtr _result = interpreter.interpret(program);
		std::vector<double> result = FloatValueCast(_result)->value();

		TS_ASSERT(result == exp_value);
	}

	void test_interpret_constant(void)
	{
		// Atomese program to be evaluated over the problem_data
		Handle c(createNumberNode(5.0));
		HandleSeq seq = {f1, f2, c};
		Handle program = createLink(seq, PLUS_LINK);

		// expected out put vector
		std::vector<double> exp_value = {6.0, 6.0, 5.0};

		// interpret
		atomese::Interpreter interpreter(dataset);
		ProtoAtomPtr _result = interpreter.interpret(program);
		std::vector<double> result = FloatValueCast(_result)->value();

		TS_ASSERT(result == exp_value);
	}

	void test_interpret_nested(void)
	{
		// Atomese program to be evaluated over the problem_data
		Handle c(createNumberNode(5.0));
		HandleSeq seq = {f1, f2};
		HandleSeq program_seq = {createLink(seq, PLUS_LINK), c};
		Handle program = createLink(program_seq, TIMES_LINK);


		// expected out put vector
		std::vector<double> exp_value = {5.0, 5.0, 0.0};

		// interpret
		atomese::Interpreter interpreter(dataset);
		ProtoAtomPtr _result = interpreter.interpret(program);
		std::vector<double> result = FloatValueCast(_result)->value();

		TS_ASSERT(result == exp_value);
	}

	void test_interpret_logical(void)
	{
		// Atomese program to be evaluated over the problem_data
		HandleSeq seq1 = {f1_tv, f2_tv};
		Handle sub_program = createLink(seq1, AND_LINK);
		HandleSeq seq2 = {sub_program, f3_tv};
		Handle program = createLink(seq2, OR_LINK);

		// expected out put vector
		std::vector<ProtoAtomPtr> exp_value = {f_link, t_link, t_link};
		ProtoAtomPtr expected(new LinkValue(exp_value));

		// interpret
		atomese::Interpreter interpreter(dataset_boolean);
		ProtoAtomPtr result = interpreter.interpret(program);

		TS_ASSERT(atomese::logical_compare(LinkValueCast(expected), LinkValueCast(result)));
	}
};
